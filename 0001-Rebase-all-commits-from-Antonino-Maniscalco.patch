From 20d6bc576e902409beef74e34da4642da71c32b8 Mon Sep 17 00:00:00 2001
From: Antonino Maniscalco <@antonino>
Date: Sun, 24 Sep 2023 11:09:18 -0300
Subject: [PATCH] Rebase all commits from Antonino Maniscalco

---
 .../drivers/zink/nir_to_spirv/nir_to_spirv.c  |  16 +-
 src/gallium/drivers/zink/zink_batch.c         |   7 +
 src/gallium/drivers/zink/zink_compiler.c      | 183 ++++++++++++++++++
 src/gallium/drivers/zink/zink_context.c       |  12 +-
 src/gallium/drivers/zink/zink_descriptors.c   | 156 ++++++++++++++-
 src/gallium/drivers/zink/zink_descriptors.h   |   7 +
 src/gallium/drivers/zink/zink_draw.cpp        |   6 +
 src/gallium/drivers/zink/zink_program.c       |  46 +++++
 src/gallium/drivers/zink/zink_program.h       |   6 +
 src/gallium/drivers/zink/zink_screen.c        |   4 +
 src/gallium/drivers/zink/zink_shader_keys.h   |   3 +-
 src/gallium/drivers/zink/zink_types.h         |  26 ++-
 12 files changed, 463 insertions(+), 9 deletions(-)

diff --git a/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c b/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c
index dc6018b..6e0549d 100644
--- a/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c
+++ b/src/gallium/drivers/zink/nir_to_spirv/nir_to_spirv.c
@@ -58,6 +58,7 @@ struct ntv_context {
    nir_variable *ubo_vars[PIPE_MAX_CONSTANT_BUFFERS];
 
    SpvId ssbos[5]; //8, 16, 32, unused, 64
+   SpvId sampler_state_ssbo;
    nir_variable *ssbo_vars;
 
    SpvId images[PIPE_MAX_SHADER_IMAGES];
@@ -69,6 +70,7 @@ struct ntv_context {
    nir_variable *bindless_sampler_var[2];
    unsigned last_sampler;
    unsigned bindless_set_idx;
+   unsigned sampler_state_set_idx;
    nir_variable *image_var[PIPE_MAX_SHADER_IMAGES]; /* driver_location -> variable */
 
    SpvId entry_ifaces[PIPE_MAX_SHADER_INPUTS * 4 + PIPE_MAX_SHADER_OUTPUTS * 4];
@@ -1335,10 +1337,15 @@ emit_bo(struct ntv_context *ctx, struct nir_variable *var, bool aliased)
    unsigned idx = bitsize >> 4;
    assert(idx < ARRAY_SIZE(ctx->ssbos));
    if (ssbo) {
-      assert(!ctx->ssbos[idx]);
-      ctx->ssbos[idx] = var_id;
-      if (bitsize == 32)
-         ctx->ssbo_vars = var;
+      if(var->data.descriptor_set != ctx->sampler_state_set_idx) {
+         assert(!ctx->ssbos[idx]);
+         ctx->ssbos[idx] = var_id;
+         if (bitsize == 32)
+            ctx->ssbo_vars = var;
+      } else {
+         ctx->sampler_state_ssbo = var_id;
+      }
+
    } else {
       assert(!ctx->ubos[var->data.driver_location][idx]);
       ctx->ubos[var->data.driver_location][idx] = var_id;
@@ -4291,6 +4298,7 @@ nir_to_spirv(struct nir_shader *s, const struct zink_shader_info *sinfo, uint32_
    ctx.spirv_1_4_interfaces = spirv_version >= SPIRV_VERSION(1, 4);
 
    ctx.bindless_set_idx = sinfo->bindless_set_idx;
+   ctx.sampler_state_set_idx = sinfo->sampler_state_set_idx;
    ctx.glsl_types = _mesa_pointer_hash_table_create(ctx.mem_ctx);
    ctx.bo_array_types = _mesa_pointer_hash_table_create(ctx.mem_ctx);
    ctx.bo_struct_types = _mesa_pointer_hash_table_create(ctx.mem_ctx);
diff --git a/src/gallium/drivers/zink/zink_batch.c b/src/gallium/drivers/zink/zink_batch.c
index af087fb..2249512 100644
--- a/src/gallium/drivers/zink/zink_batch.c
+++ b/src/gallium/drivers/zink/zink_batch.c
@@ -465,6 +465,13 @@ zink_batch_bind_db(struct zink_context *ctx)
       infos[1].usage = ctx->dd.db.bindless_db->obj->vkusage;
       assert(infos[1].usage);
       count++;
+   }
+    if (ctx->dd.db.sampler_state_db) {
+      infos[count].sType = VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT;
+      infos[count].address = ctx->dd.db.sampler_state_db->obj->bda;
+      infos[count].usage = ctx->dd.db.sampler_state_db->obj->vkusage;
+      assert(infos[count].usage);
+      count++;
    }
    VKSCR(CmdBindDescriptorBuffersEXT)(batch->state->cmdbuf, count, infos);
    VKSCR(CmdBindDescriptorBuffersEXT)(batch->state->barrier_cmdbuf, count, infos);
diff --git a/src/gallium/drivers/zink/zink_compiler.c b/src/gallium/drivers/zink/zink_compiler.c
index e678e9e..55e26e8 100644
--- a/src/gallium/drivers/zink/zink_compiler.c
+++ b/src/gallium/drivers/zink/zink_compiler.c
@@ -1021,6 +1021,183 @@ lower_line_smooth_fs(nir_shader *shader, bool lower_stipple)
    return true;
 }
 
+static nir_def*
+emit_texture_query_load(nir_builder *b, nir_def *p, nir_def *tsize)
+{
+   nir_def *pixel_p = nir_fmul(b, tsize, p);
+   nir_def *ddx = nir_fddx(b, pixel_p);
+   nir_def *ddy = nir_fddy(b, pixel_p);
+   nir_def *lambda = nir_fmul_imm(b, nir_flog2(b, nir_fmax(b, nir_fdot(b, ddx, ddx),
+                                                               nir_fdot(b, ddy, ddy))),
+                                      0.5);
+   return nir_fmax(b, lambda, nir_imm_float(b, 0.0));
+}
+
+// copied from src/compiler/nir/nir_builtin_builder.c:352
+static
+nir_def *
+zink_get_texture_size_lod(nir_builder *b, nir_tex_instr *tex, nir_def *lod)
+{
+   //b->cursor = nir_before_instr(&tex->instr);
+
+   nir_tex_instr *txs;
+
+   unsigned num_srcs = 1; /* One for the LOD */
+   for (unsigned i = 0; i < tex->num_srcs; i++) {
+      if (tex->src[i].src_type == nir_tex_src_texture_deref ||
+          tex->src[i].src_type == nir_tex_src_sampler_deref ||
+          tex->src[i].src_type == nir_tex_src_texture_offset ||
+          tex->src[i].src_type == nir_tex_src_sampler_offset ||
+          tex->src[i].src_type == nir_tex_src_texture_handle ||
+          tex->src[i].src_type == nir_tex_src_sampler_handle)
+         num_srcs++;
+   }
+
+   txs = nir_tex_instr_create(b->shader, num_srcs);
+   txs->op = nir_texop_txs;
+   txs->sampler_dim = tex->sampler_dim;
+   txs->is_array = tex->is_array;
+   txs->is_shadow = tex->is_shadow;
+   txs->is_new_style_shadow = tex->is_new_style_shadow;
+   txs->texture_index = tex->texture_index;
+   txs->sampler_index = tex->sampler_index;
+   txs->dest_type = nir_type_int32;
+
+   unsigned idx = 0;
+   for (unsigned i = 0; i < tex->num_srcs; i++) {
+      if (tex->src[i].src_type == nir_tex_src_texture_deref ||
+          tex->src[i].src_type == nir_tex_src_sampler_deref ||
+          tex->src[i].src_type == nir_tex_src_texture_offset ||
+          tex->src[i].src_type == nir_tex_src_sampler_offset ||
+          tex->src[i].src_type == nir_tex_src_texture_handle ||
+          tex->src[i].src_type == nir_tex_src_sampler_handle) {
+         nir_src_copy(&txs->src[idx].src, &tex->src[i].src, &txs->instr);
+         txs->src[idx].src_type = tex->src[i].src_type;
+         idx++;
+      }
+   }
+   /* Add in an LOD because some back-ends require it */
+   txs->src[idx].src = lod;
+   txs->src[idx].src_type = nir_tex_src_lod;
+
+   nir_def_init(&txs->instr, &txs->dest,
+                     nir_tex_instr_dest_size(txs), 32, NULL);
+   nir_builder_instr_insert(b, &txs->instr);
+
+   return &txs->dest.ssa;
+}
+
+struct lower_border_color_state {
+   nir_variable *sampler_state;
+};
+
+/**
+ * This NIR lowers .
+ */
+
+static bool
+lower_border_color_instr(nir_builder *b, nir_instr *instr, void *state)
+{
+   struct lower_border_color_state *s = state;
+   if (instr->type != nir_instr_type_tex)
+      return false;
+
+   nir_tex_instr *tex_instr = nir_instr_as_tex(instr);
+   /* nir_texop_tex,                < Regular texture look-up
+    * nir_texop_txb,                < Texture look-up with LOD bias
+    * nir_texop_txl,                < Texture look-up with explicit LOD
+    * nir_texop_txd,                < Texture look-up with partial derivatives
+    * */
+   if (tex_instr->op != nir_texop_tex)
+      return false;
+
+   int coord_index = nir_tex_instr_src_index(tex_instr, nir_tex_src_coord);
+   int lod_index = nir_tex_instr_src_index(tex_instr, nir_tex_src_lod);
+
+   nir_def *tsize;
+   nir_def *lod0_size = nir_get_texture_size(b, tex_instr);
+   b->cursor = nir_after_instr(instr);
+   nir_def *uv = nir_ssa_for_src(b, tex_instr->src[coord_index].src, 2),
+               *ret = &tex_instr->dest.ssa;//TODO actually get those, texture size, coords, sample
+
+   nir_deref_instr *border_color_data = nir_build_deref_struct(b, nir_build_deref_array_imm(b, nir_build_deref_var(b, s->sampler_state), /*tex_instr->texture_index*/0), 0);
+   nir_def *border_color_components[4];
+   for (unsigned i = 0; i < 4; i++)
+      border_color_components[i] = nir_load_deref(b, nir_build_deref_array_imm(b, border_color_data, tex_instr->texture_index * 5 + i));
+   nir_def *border_color = nir_vec4(b, border_color_components[0], border_color_components[1], border_color_components[2], border_color_components[3]);
+   nir_def *wrap = nir_load_deref(b, nir_build_deref_array_imm(b, border_color_data, tex_instr->texture_index * 5 + 4));
+
+   bool mip_maps = false;
+   if (mip_maps) {
+      tsize = nir_i2f32(b, lod0_size);
+   } else {
+      nir_cursor cursor = b->cursor;
+      nir_def *lod = tex_instr->op == nir_texop_tex ?
+                                          nir_get_texture_lod(b, tex_instr) :
+                                          nir_ssa_for_src(b, tex_instr->src[lod_index].src, 1);
+      b->cursor = cursor;
+      nir_def *size0 = zink_get_texture_size_lod(b, tex_instr, nir_f2i32(b, nir_ffloor(b, lod)));
+      nir_def *size1 = zink_get_texture_size_lod(b, tex_instr, nir_f2i32(b, nir_fceil(b, lod)));
+      tsize = nir_flrp(b, nir_i2f32(b, size0), nir_i2f32(b, size1), nir_ffract(b, lod));
+   }
+
+   nir_def *wrap_s = nir_iand_imm(b, nir_ushr_imm(b, wrap, 3), 0b111);
+   nir_def *wrap_t = nir_iand_imm(b, nir_ushr_imm(b, wrap, 6), 0b111);
+   nir_def *limit_s = nir_bcsel(b, nir_b2b1(b, nir_iand_imm(b, wrap_s,
+                                                                PIPE_TEX_WRAP_CLAMP_TO_BORDER)),
+                                    nir_imm_float(b, 1.0), nir_imm_float(b, 0.5));
+   nir_def *limit_t = nir_bcsel(b, nir_b2b1(b, nir_iand_imm(b, wrap_t,
+                                                                PIPE_TEX_WRAP_CLAMP_TO_BORDER)),
+                                    nir_imm_float(b, 1.0), nir_imm_float(b, 0.5));
+   nir_def *limit = nir_vec2(b, limit_s, limit_t);
+   nir_def *pixel_uv = nir_fadd(b, nir_imm_vec2(b, 0.5, 0.5),
+                                    nir_fmul(b, nir_fsub(b, nir_fabs(b, nir_fsub(b, uv, nir_imm_vec2(b, 0.5, 0.5))),
+                                                         nir_imm_vec2(b, 0.5, 0.5)),
+                                             tsize));
+   nir_def *factors = nir_fclamp(b, pixel_uv, nir_imm_vec2(b, 0.0, 0.0), limit);
+   nir_def *factor, *new_ret;
+   factor = nir_channel(b, factors, 0);//WRAP X/Y
+   new_ret = nir_bcsel(b, nir_b2b1(b, nir_iand_imm(b, wrap_s,
+                                                   PIPE_TEX_WRAP_CLAMP_TO_BORDER | PIPE_TEX_WRAP_CLAMP_TO_EDGE)),
+                       nir_flrp(b, ret, border_color, factor), ret);
+   factor = nir_channel(b, factors, 1);//WRAP X/Y
+   new_ret = nir_bcsel(b, nir_b2b1(b, nir_iand_imm(b, wrap_t,
+                                                   PIPE_TEX_WRAP_CLAMP_TO_BORDER | PIPE_TEX_WRAP_CLAMP_TO_EDGE)),
+                       nir_flrp(b, new_ret, border_color, factor), new_ret);
+   nir_def_rewrite_uses_after(ret, new_ret, b->cursor.instr);
+
+   return true;
+}
+
+static bool
+lower_border_color_pass(nir_shader *shader, nir_variable *border_color)
+{
+   assert(shader->info.stage == MESA_SHADER_FRAGMENT);
+   return nir_shader_instructions_pass(shader, lower_border_color_instr,
+                                       nir_metadata_loop_analysis |
+                                       nir_metadata_block_index |
+                                       nir_metadata_dominance,
+                                       &(struct lower_border_color_state) {
+                                          .sampler_state = border_color
+                                       });
+}
+static void
+lower_border_color(struct zink_screen *screen, nir_shader *shader)
+{
+   struct glsl_struct_field *fields = rzalloc_array(shader, struct glsl_struct_field, PIPE_MAX_SAMPLERS);
+   fields[0].type = glsl_array_type(glsl_uint_type(), 4, 0);
+   fields[0].name = "border_color";
+   fields[0].offset = 0;
+   nir_variable *border_color = nir_variable_create(shader, nir_var_mem_ssbo,
+                                                    glsl_array_type(glsl_struct_type(fields, 1, "sampler_state", true),
+                                                                    PIPE_MAX_SAMPLERS, 0),
+                                                    "sampler_state");
+   border_color->data.descriptor_set = screen->desc_set_id[ZINK_DESCRIPTOR_SAMPLER_STATE];
+   border_color->data.driver_location = 0;
+   border_color->data.mode = nir_var_mem_ssbo;
+   NIR_PASS_V(shader, lower_border_color_pass, border_color);
+}
+
 static bool
 lower_dual_blend(nir_shader *shader)
 {
@@ -3842,6 +4019,11 @@ zink_shader_compile(struct zink_screen *screen, bool can_shobj, struct zink_shad
             need_optimize = true;
          }
 
+         if (zink_fs_key(key)->lower_border_color) {
+            lower_border_color(screen, nir);
+            need_optimize = true;
+         }
+
          if (zink_fs_key(key)->robust_access)
             NIR_PASS(need_optimize, nir, lower_txf_lod_robustness);
 
@@ -5325,6 +5507,7 @@ zink_shader_create(struct zink_screen *screen, struct nir_shader *nir)
    ret->sinfo.have_vulkan_memory_model = screen->info.have_KHR_vulkan_memory_model;
    ret->sinfo.have_workgroup_memory_explicit_layout = screen->info.have_KHR_workgroup_memory_explicit_layout;
    ret->sinfo.bindless_set_idx = screen->desc_set_id[ZINK_DESCRIPTOR_BINDLESS];
+   ret->sinfo.sampler_state_set_idx = screen->desc_set_id[ZINK_DESCRIPTOR_SAMPLER_STATE];
 
    util_queue_fence_init(&ret->precompile.fence);
    util_dynarray_init(&ret->pipeline_libs, ret);
diff --git a/src/gallium/drivers/zink/zink_context.c b/src/gallium/drivers/zink/zink_context.c
index eef41b8..e03af36 100644
--- a/src/gallium/drivers/zink/zink_context.c
+++ b/src/gallium/drivers/zink/zink_context.c
@@ -152,6 +152,7 @@ zink_context_destroy(struct pipe_context *pctx)
    zink_buffer_view_reference(screen, &ctx->dummy_bufferview, NULL);
 
    zink_descriptors_deinit_bindless(ctx);
+   zink_descriptors_deinit_sampler_state(ctx);
 
    struct zink_batch_state *bs = ctx->batch_states;
    while (bs) {
@@ -550,6 +551,11 @@ zink_create_sampler_state(struct pipe_context *pctx,
       }
    }
    sampler->custom_border_color = need_custom;
+   sampler->border_color = state->border_color;
+   sampler->border_color_format = state->border_color_format;
+   sampler->wrap_r = state->wrap_r;
+   sampler->wrap_s = state->wrap_s;
+   sampler->wrap_t = state->wrap_t;
    if (!screen->info.have_EXT_non_seamless_cube_map)
       sampler->emulate_nonseamless = !state->seamless_cube_map;
 
@@ -828,9 +834,11 @@ zink_bind_sampler_states(struct pipe_context *pctx,
                  (surface->base.format == PIPE_FORMAT_Z24_UNORM_S8_UINT && surface->ivci.format == VK_FORMAT_D32_SFLOAT_S8_UINT)))
                ctx->di.textures[shader][start_slot + i].sampler = state->sampler_clamped;
          }
+         ctx->sampler_dirty_flags[shader] |= BITFIELD_BIT(i);
       } else {
          ctx->di.textures[shader][start_slot + i].sampler = VK_NULL_HANDLE;
-      }
+	 ctx->sampler_dirty_flags[shader] &= ~BITFIELD_BIT(i);
+     }
    }
    ctx->di.num_samplers[shader] = start_slot + num_samplers;
 }
@@ -5343,6 +5351,8 @@ zink_context_create(struct pipe_screen *pscreen, void *priv, unsigned flags)
    if (!ctx->batch.state)
       goto fail;
 
+   zink_descriptors_init_sampler_state(ctx);
+
    if (screen->compact_descriptors)
       ctx->invalidate_descriptor_state = zink_context_invalidate_descriptor_state_compact;
    else
diff --git a/src/gallium/drivers/zink/zink_descriptors.c b/src/gallium/drivers/zink/zink_descriptors.c
index 04d4d26..a81eff0 100644
--- a/src/gallium/drivers/zink/zink_descriptors.c
+++ b/src/gallium/drivers/zink/zink_descriptors.c
@@ -603,10 +603,13 @@ zink_descriptor_program_init(struct zink_context *ctx, struct zink_program *pg)
       }
    }
    /* TODO: make this dynamic so that bindless set id can be 0 if no other descriptors are used? */
-   if (pg->dd.bindless) {
+   if (true || pg->dd.bindless) {
       unsigned desc_set = screen->desc_set_id[ZINK_DESCRIPTOR_BINDLESS];
-      pg->num_dsl = desc_set + 1;
+      pg->num_dsl = desc_set + 2;
+      if (pg->dd.bindless)
       pg->dsl[desc_set] = screen->bindless_layout;
+      desc_set = screen->desc_set_id[ZINK_DESCRIPTOR_SAMPLER_STATE];
+      pg->dsl[desc_set] = ctx->dd.sampler_state_dsl;
       /* separate handling for null set injection when only bindless descriptors are used */
       for (unsigned i = 0; i < desc_set; i++) {
          if (!pg->dsl[i]) {
@@ -650,6 +653,7 @@ zink_descriptor_program_init(struct zink_context *ctx, struct zink_program *pg)
       /* no need for empty templates */
       if (pg->dsl[i] == ctx->dd.dummy_dsl->layout ||
           pg->dsl[i] == screen->bindless_layout ||
+          pg->dsl[i] == ctx->dd.sampler_state_dsl ||
           (!is_push && pg->dd.templates[i]))
          continue;
       template[i].sType = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO;
@@ -1849,3 +1853,151 @@ zink_descriptors_update_bindless(struct zink_context *ctx)
    }
    ctx->di.any_bindless_dirty = 0;
 }
+
+void
+zink_descriptors_init_sampler_state(struct zink_context *ctx)
+{
+   struct zink_screen *screen = (struct zink_screen*)ctx->base.screen;
+   uint64_t sampler_state_size = PIPE_MAX_SAMPLERS * sizeof(struct zink_gpu_sampler_state);//TODO proper size
+   VkBufferCreateInfo bci;
+   bci.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
+   bci.pNext = NULL;
+   bci.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
+   bci.queueFamilyIndexCount = 0;
+   bci.pQueueFamilyIndices = NULL;
+   bci.size = sampler_state_size;
+   bci.usage = (ZINK_DESCRIPTOR_MODE_DB ? VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT : 0) | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT;
+   bci.flags = 0;
+   VKCTX(CreateBuffer)(screen->dev, &bci, NULL, &ctx->sampler_state_buffer);
+   struct pb_buffer *buf = zink_bo_create(screen, sampler_state_size, ZINK_SPARSE_BUFFER_PAGE_SIZE,
+                                          ZINK_HEAP_DEVICE_LOCAL, 0, screen->heap_map[ZINK_HEAP_DEVICE_LOCAL][0], NULL);
+   ctx->sampler_state_bo = zink_bo(buf);
+   VKCTX(BindBufferMemory)(screen->dev, ctx->sampler_state_buffer, ctx->sampler_state_bo->mem, 0);
+
+   VkDescriptorSetLayoutCreateInfo linfo = {
+      .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
+      .bindingCount = 1,
+      .pBindings = &(VkDescriptorSetLayoutBinding) {
+         .binding = 0,
+         .descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
+         .descriptorCount = 1,
+      },
+      .flags = zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB ? VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT : 0,
+   };
+   VkDescriptorSetLayout layout;
+   VKCTX(CreateDescriptorSetLayout)(screen->dev, &linfo, NULL, &layout);
+   ctx->dd.sampler_state_dsl = layout;
+
+   if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
+      VKSCR(GetDescriptorSetLayoutSizeEXT)(screen->dev, ctx->dd.sampler_state_dsl, &ctx->dd.db.sampler_state_ds_size);
+      VKSCR(GetDescriptorSetLayoutBindingOffsetEXT)(screen->dev, ctx->dd.sampler_state_dsl, 0, &ctx->dd.db.sampler_state_ds_offset);
+
+      unsigned bind = ZINK_BIND_RESOURCE_DESCRIPTOR | ZINK_BIND_SAMPLER_DESCRIPTOR;
+      struct pipe_resource *pres = pipe_buffer_create(&screen->base, bind, 0, ctx->dd.db.sampler_state_ds_size);
+      ctx->dd.db.sampler_state_db = zink_resource(pres);
+      ctx->dd.db.sampler_state_db_map = pipe_buffer_map(&ctx->base, pres, PIPE_MAP_READ | PIPE_MAP_WRITE, &ctx->dd.db.sampler_state_db_xfer);
+      zink_batch_bind_db(ctx);
+
+      VkDeviceAddress sampler_state_address;
+      sampler_state_address = VKCTX(GetBufferDeviceAddress)(screen->dev,
+                                                            &(VkBufferDeviceAddressInfo){
+                                                               .sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
+                                                               .buffer = ctx->sampler_state_buffer,
+                                                            });
+      VkDescriptorGetInfoEXT info = {
+         .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT,
+         .type = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
+         .data = (VkDescriptorDataEXT){
+            .pStorageBuffer = &(VkDescriptorAddressInfoEXT){
+               .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT,
+               .address = sampler_state_address,
+               .range = sampler_state_size,
+            },
+         },
+      };
+      VKSCR(GetDescriptorEXT)(screen->dev, &info, ctx->dd.db.sampler_state_ds_size,
+                              ctx->dd.db.sampler_state_db_map + ctx->dd.db.sampler_state_ds_offset);
+   } else {
+      VkDescriptorPoolCreateInfo pi = {
+         .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
+         .maxSets = 1,
+         .poolSizeCount = 1,
+         .pPoolSizes = &(VkDescriptorPoolSize){
+            .type = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
+            .descriptorCount = 1,
+         },
+      };
+      VkDescriptorPool pool;
+      VKCTX(CreateDescriptorPool)(screen->dev, &pi, NULL, &pool);
+
+      VkDescriptorSetAllocateInfo dsi = {
+         .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
+         .descriptorPool = pool,
+         .descriptorSetCount = 1,
+         .pSetLayouts  = &layout,
+      };
+      VkDescriptorSet sampler_state_descriptor;
+      VKCTX(AllocateDescriptorSets)(screen->dev, &dsi, &sampler_state_descriptor);
+      VKCTX(UpdateDescriptorSets)(screen->dev,
+                                  1, &(VkWriteDescriptorSet){
+                                     .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
+                                     .dstSet = sampler_state_descriptor,
+                                     .dstBinding = 0,
+                                     .dstArrayElement = 0,
+                                     .descriptorCount = 1,
+                                     .descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
+                                     .pBufferInfo = &(VkDescriptorBufferInfo){
+                                        .buffer = ctx->sampler_state_buffer,
+                                        .offset = 0,
+                                        .range = VK_WHOLE_SIZE,
+                                     },
+                                  },
+                                  0, NULL);
+      ctx->dd.t.sampler_state_ds = sampler_state_descriptor;
+   }
+
+}
+
+void
+zink_descriptors_deinit_sampler_state(struct zink_context *ctx)
+{
+   struct zink_screen *screen = zink_screen(ctx->base.screen);
+   if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
+      if (ctx->dd.db.sampler_state_db_xfer)
+         pipe_buffer_unmap(&ctx->base, ctx->dd.db.sampler_state_db_xfer);
+      if (ctx->dd.db.sampler_state_db) {
+         struct pipe_resource *pres = &ctx->dd.db.sampler_state_db->base.b;
+         pipe_resource_reference(&pres, NULL);
+      }
+   } else {
+      if (ctx->dd.t.sampler_state_pool)
+         VKSCR(DestroyDescriptorPool)(screen->dev, ctx->dd.t.sampler_state_pool, NULL);
+   }
+   VKSCR(DestroyBuffer)(screen->dev, ctx->sampler_state_buffer, NULL);
+   zink_bo_unref(screen, ctx->sampler_state_bo);
+   VKSCR(DestroyDescriptorSetLayout)(screen->dev, ctx->dd.sampler_state_dsl, NULL);
+}
+
+void
+zink_descriptors_update_sampler_state(struct zink_context *ctx, struct zink_batch *batch)
+{
+   struct zink_screen *screen = (struct zink_screen*)ctx->base.screen;
+   if (ctx->curr_program->base.num_dsl < screen->desc_set_id[ZINK_DESCRIPTOR_SAMPLER_STATE])
+      return;
+   if (zink_descriptor_mode == ZINK_DESCRIPTOR_MODE_DB) {
+      uint32_t buffer_index = 1;
+      VKCTX(CmdSetDescriptorBufferOffsetsEXT)(batch->state->cmdbuf,
+                                              VK_PIPELINE_BIND_POINT_GRAPHICS,
+                                              ctx->curr_program->base.layout,
+                                              screen->desc_set_id[ZINK_DESCRIPTOR_SAMPLER_STATE],
+                                              1, &buffer_index, &ctx->dd.db.sampler_state_ds_offset);
+   }
+   else
+      VKCTX(CmdBindDescriptorSets)(batch->state->cmdbuf,
+                                   VK_PIPELINE_BIND_POINT_GRAPHICS,
+                                   ctx->curr_program->base.layout,
+                                   screen->desc_set_id[ZINK_DESCRIPTOR_SAMPLER_STATE],
+                                   1, &ctx->dd.t.sampler_state_ds,
+                                   0, NULL);
+
+}
diff --git a/src/gallium/drivers/zink/zink_descriptors.h b/src/gallium/drivers/zink/zink_descriptors.h
index 8280a05..7f3d239 100644
--- a/src/gallium/drivers/zink/zink_descriptors.h
+++ b/src/gallium/drivers/zink/zink_descriptors.h
@@ -154,6 +154,13 @@ zink_descriptors_deinit_bindless(struct zink_context *ctx);
 void
 zink_descriptors_update_bindless(struct zink_context *ctx);
 
+void
+zink_descriptors_init_sampler_state(struct zink_context *ctx);
+void
+zink_descriptors_deinit_sampler_state(struct zink_context *ctx);
+void
+zink_descriptors_update_sampler_state(struct zink_context *ctx, struct zink_batch *batch);
+
 void
 zink_descriptor_shader_get_binding_offsets(const struct zink_shader *shader, unsigned *offsets);
 void
diff --git a/src/gallium/drivers/zink/zink_draw.cpp b/src/gallium/drivers/zink/zink_draw.cpp
index 2946e26..75f58ce 100644
--- a/src/gallium/drivers/zink/zink_draw.cpp
+++ b/src/gallium/drivers/zink/zink_draw.cpp
@@ -653,6 +653,10 @@ zink_draw(struct pipe_context *pctx,
       zink_set_primitive_emulation_keys(ctx);
    }
 
+   zink_set_border_color_emulation_keys(ctx);
+
+   zink_update_sampler_state_buffer(ctx);
+
    if (index_size) {
       const VkIndexType index_type[3] = {
          VK_INDEX_TYPE_UINT8_EXT,
@@ -916,6 +920,8 @@ zink_draw(struct pipe_context *pctx,
        ctx->curr_program->base.dd.bindless)
       zink_descriptors_update_bindless(ctx);
 
+      zink_descriptors_update_sampler_state(ctx, &ctx->batch);
+
    if (reads_basevertex) {
       unsigned draw_mode_is_indexed = index_size > 0;
       if (unlikely(can_dgc)) {
diff --git a/src/gallium/drivers/zink/zink_program.c b/src/gallium/drivers/zink/zink_program.c
index 5441843..7f9fc62 100644
--- a/src/gallium/drivers/zink/zink_program.c
+++ b/src/gallium/drivers/zink/zink_program.c
@@ -1251,6 +1251,8 @@ create_gfx_program_separable(struct zink_context *ctx, struct zink_shader **stag
       prog->base.num_dsl = screen->compact_descriptors ? ZINK_DESCRIPTOR_ALL_TYPES - ZINK_DESCRIPTOR_COMPACT : ZINK_DESCRIPTOR_ALL_TYPES;
       prog->base.dsl[screen->desc_set_id[ZINK_DESCRIPTOR_BINDLESS]] = screen->bindless_layout;
    }
+   prog->base.num_dsl = screen->compact_descriptors ? ZINK_DESCRIPTOR_ALL_TYPES - ZINK_DESCRIPTOR_COMPACT : ZINK_DESCRIPTOR_ALL_TYPES;
+   prog->base.dsl[screen->desc_set_id[ZINK_DESCRIPTOR_SAMPLER_STATE]] = ctx->dd.sampler_state_dsl;
    prog->base.layout = zink_pipeline_layout_create(screen, prog->base.dsl, prog->base.num_dsl, false, VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT);
 
    prog->last_variant_hash = ctx->gfx_pipeline_state.optimal_key;
@@ -2487,3 +2489,47 @@ zink_set_primitive_emulation_keys(struct zink_context *ctx)
               ctx->gfx_stages[MESA_SHADER_GEOMETRY]->non_fs.is_generated)
          ctx->base.bind_gs_state(&ctx->base, NULL);
 }
+
+void
+zink_set_border_color_emulation_keys(struct zink_context *ctx)
+{
+   struct zink_screen *screen = zink_screen(ctx->base.screen);
+   if (!screen->info.have_EXT_custom_border_color) {
+      // TODO move somehwre else
+      // TODO make it work for all stages
+      bool lower_border_color = 0;
+      for (unsigned i = 0; i < PIPE_MAX_SAMPLERS; i++)
+         if (ctx->sampler_states[MESA_SHADER_FRAGMENT][i] &&
+             ctx->sampler_states[MESA_SHADER_FRAGMENT][i]->custom_border_color) {
+            lower_border_color = true;
+            break;
+         }
+      if (zink_get_fs_key(ctx)->lower_border_color != lower_border_color)
+         zink_set_fs_key(ctx)->lower_border_color = lower_border_color;
+   }
+}
+
+void
+zink_update_sampler_state_buffer(struct zink_context *ctx)
+{
+   struct zink_screen *screen = zink_screen(ctx->base.screen);
+   if (!screen->info.have_EXT_custom_border_color &&
+       ctx->sampler_dirty_flags[MESA_SHADER_FRAGMENT]) {
+      for (unsigned int i = 0; i < PIPE_MAX_SAMPLERS; i++)
+         //TODO handle formats
+         if (ctx->sampler_states[MESA_SHADER_FRAGMENT][i] &&
+             ctx->sampler_states[MESA_SHADER_FRAGMENT][i]->custom_border_color) {
+            memcpy((void*)&ctx->gpu_sampler_states[MESA_SHADER_FRAGMENT][i].border_color,
+                   (void*)&ctx->sampler_states[MESA_SHADER_FRAGMENT][i]->border_color.f,
+                   sizeof(ctx->gpu_sampler_states[MESA_SHADER_FRAGMENT][0].border_color));
+            ctx->gpu_sampler_states[MESA_SHADER_FRAGMENT][i].wrap = ctx->sampler_states[MESA_SHADER_FRAGMENT][i]->wrap_r |
+                                                                    ctx->sampler_states[MESA_SHADER_FRAGMENT][i]->wrap_s << 3 |
+                                                                    ctx->sampler_states[MESA_SHADER_FRAGMENT][i]->wrap_t << 6;
+         }
+      VKCTX(CmdUpdateBuffer)(ctx->batch.state->cmdbuf, ctx->sampler_state_buffer, 0,
+                             PIPE_MAX_SAMPLERS * sizeof(struct zink_gpu_sampler_state),
+                             &ctx->gpu_sampler_states[MESA_SHADER_FRAGMENT][0]);
+      ctx->sampler_dirty_flags[MESA_SHADER_FRAGMENT] = 0;
+   }
+
+}
diff --git a/src/gallium/drivers/zink/zink_program.h b/src/gallium/drivers/zink/zink_program.h
index 8df5e33..ed6f978 100644
--- a/src/gallium/drivers/zink/zink_program.h
+++ b/src/gallium/drivers/zink/zink_program.h
@@ -376,6 +376,12 @@ zink_get_shader_key_base(const struct zink_context *ctx, gl_shader_stage pstage)
    return &ctx->gfx_pipeline_state.shader_keys.key[pstage].base;
 }
 
+void
+zink_set_border_color_emulation_keys(struct zink_context *ctx);
+
+void
+zink_update_sampler_state_buffer(struct zink_context *ctx);
+
 static inline struct zink_shader_key_base *
 zink_set_shader_key_base(struct zink_context *ctx, gl_shader_stage pstage)
 {
diff --git a/src/gallium/drivers/zink/zink_screen.c b/src/gallium/drivers/zink/zink_screen.c
index df66a2a..65c4dc2 100644
--- a/src/gallium/drivers/zink/zink_screen.c
+++ b/src/gallium/drivers/zink/zink_screen.c
@@ -2617,6 +2617,7 @@ zink_get_sample_pixel_grid(struct pipe_screen *pscreen, unsigned sample_count,
 static void
 init_driver_workarounds(struct zink_screen *screen)
 {
+   screen->info.have_EXT_custom_border_color = false;
    /* enable implicit sync for all non-mesa drivers */
    screen->driver_workarounds.implicit_sync = true;
    switch (screen->info.driver_props.driverID) {
@@ -2886,6 +2887,7 @@ init_optimal_keys(struct zink_screen *screen)
    screen->optimal_keys = !screen->need_decompose_attrs &&
                           screen->info.have_EXT_non_seamless_cube_map &&
                           screen->info.have_EXT_provoking_vertex &&
+                          screen->info.have_EXT_custom_border_color &&
                           !screen->driconf.inline_uniforms &&
                           !screen->driver_workarounds.no_linestipple &&
                           !screen->driver_workarounds.no_linesmooth &&
@@ -3236,6 +3238,7 @@ zink_internal_create_screen(const struct pipe_screen_config *config, int64_t dev
       screen->desc_set_id[ZINK_DESCRIPTOR_TYPE_SAMPLER_VIEW] = 2;
       screen->desc_set_id[ZINK_DESCRIPTOR_TYPE_IMAGE] = 2;
       screen->desc_set_id[ZINK_DESCRIPTOR_BINDLESS] = 3;
+      screen->desc_set_id[ZINK_DESCRIPTOR_SAMPLER_STATE] = 4;
       screen->compact_descriptors = true;
    } else {
       screen->desc_set_id[ZINK_DESCRIPTOR_TYPE_UNIFORMS] = 0;
@@ -3244,6 +3247,7 @@ zink_internal_create_screen(const struct pipe_screen_config *config, int64_t dev
       screen->desc_set_id[ZINK_DESCRIPTOR_TYPE_SSBO] = 3;
       screen->desc_set_id[ZINK_DESCRIPTOR_TYPE_IMAGE] = 4;
       screen->desc_set_id[ZINK_DESCRIPTOR_BINDLESS] = 5;
+      screen->desc_set_id[ZINK_DESCRIPTOR_SAMPLER_STATE] = 6;
    }
 
    if (screen->info.have_EXT_calibrated_timestamps && !check_have_device_time(screen))
diff --git a/src/gallium/drivers/zink/zink_shader_keys.h b/src/gallium/drivers/zink/zink_shader_keys.h
index 1dab244..e9e3ccb 100644
--- a/src/gallium/drivers/zink/zink_shader_keys.h
+++ b/src/gallium/drivers/zink/zink_shader_keys.h
@@ -96,8 +96,9 @@ struct zink_fs_key {
    bool lower_line_stipple : 1;
    bool lower_line_smooth : 1;
    bool lower_point_smooth : 1;
+   bool lower_border_color: 1;
    bool robust_access : 1;
-   uint16_t pad2 : 12;
+   uint16_t pad2 : 11;
 };
 
 struct zink_tcs_key {
diff --git a/src/gallium/drivers/zink/zink_types.h b/src/gallium/drivers/zink/zink_types.h
index 3350f11..d6bb7be 100644
--- a/src/gallium/drivers/zink/zink_types.h
+++ b/src/gallium/drivers/zink/zink_types.h
@@ -78,7 +78,7 @@
 #define ZINK_MAX_BINDLESS_HANDLES 1024
 
 /* enum zink_descriptor_type */
-#define ZINK_MAX_DESCRIPTOR_SETS 6
+#define ZINK_MAX_DESCRIPTOR_SETS 7
 #define ZINK_MAX_DESCRIPTORS_PER_TYPE (32 * ZINK_GFX_SHADER_COUNT)
 /* Descriptor size reported by lavapipe. */
 #define ZINK_FBFETCH_DESCRIPTOR_SIZE 280
@@ -160,6 +160,7 @@ enum zink_descriptor_type {
    ZINK_DESCRIPTOR_TYPE_IMAGE,
    ZINK_DESCRIPTOR_BASE_TYPES, /**< the count/iterator for basic descriptor types */
    ZINK_DESCRIPTOR_BINDLESS,
+   ZINK_DESCRIPTOR_SAMPLER_STATE,
    ZINK_DESCRIPTOR_ALL_TYPES,
    ZINK_DESCRIPTOR_TYPE_UNIFORMS = ZINK_DESCRIPTOR_BASE_TYPES, /**< this is aliased for convenience */
    ZINK_DESCRIPTOR_NON_BINDLESS_TYPES = ZINK_DESCRIPTOR_BASE_TYPES + 1, /**< for struct sizing */
@@ -438,10 +439,14 @@ struct zink_descriptor_data {
 
    struct zink_descriptor_layout *dummy_dsl;
 
+   VkDescriptorSetLayout sampler_state_dsl;
+
    union {
       struct {
          VkDescriptorPool bindless_pool;
          VkDescriptorSet bindless_set;
+         VkDescriptorPool sampler_state_pool;
+         VkDescriptorSet sampler_state_ds;
       } t;
       struct {
          struct zink_resource *bindless_db;
@@ -449,6 +454,11 @@ struct zink_descriptor_data {
          struct pipe_transfer *bindless_db_xfer;
          uint32_t bindless_db_offsets[4];
          unsigned max_db_size;
+
+	 VkDeviceSize sampler_state_ds_size, sampler_state_ds_offset;
+         struct zink_resource *sampler_state_db;
+         uint8_t *sampler_state_db_map;
+         struct pipe_transfer *sampler_state_db_xfer;
       } db;
    };
 
@@ -767,6 +777,7 @@ struct zink_shader_info {
    bool have_vulkan_memory_model;
    bool have_workgroup_memory_explicit_layout;
    unsigned bindless_set_idx;
+   unsigned sampler_state_set_idx;
 };
 
 enum zink_rast_prim {
@@ -1635,12 +1646,21 @@ struct zink_framebuffer {
    struct hash_table objects;
 };
 
+struct zink_gpu_sampler_state {
+   float border_color[4];
+   unsigned wrap;
+};
 
 /** context types */
 struct zink_sampler_state {
    VkSampler sampler;
    VkSampler sampler_clamped;
    bool custom_border_color;
+   union pipe_color_union border_color;
+   enum pipe_format border_color_format;
+   unsigned wrap_s:3;            /**< PIPE_TEX_WRAP_x */
+   unsigned wrap_t:3;            /**< PIPE_TEX_WRAP_x */
+   unsigned wrap_r:3;            /**< PIPE_TEX_WRAP_x */
    bool emulate_nonseamless;
 };
 
@@ -1862,7 +1882,11 @@ struct zink_context {
    bool vertex_buffers_dirty;
 
    struct zink_sampler_state *sampler_states[MESA_SHADER_STAGES][PIPE_MAX_SAMPLERS];
+   struct zink_gpu_sampler_state gpu_sampler_states[MESA_SHADER_STAGES][PIPE_MAX_SAMPLERS];
+   uint32_t sampler_dirty_flags[MESA_SHADER_STAGES];
    struct pipe_sampler_view *sampler_views[MESA_SHADER_STAGES][PIPE_MAX_SAMPLERS];
+   VkBuffer sampler_state_buffer;
+   struct zink_bo *sampler_state_bo;
 
    struct zink_viewport_state vp_state;
    bool vp_state_changed;
-- 
2.41.0

